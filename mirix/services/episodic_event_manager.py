import uuid
from typing import List, Optional, Dict, Any

import datetime as dt
from datetime import datetime
from mirix.orm.errors import NoResultFound
from mirix.orm.episodic_event import EpisodicEvent
from mirix.schemas.user import User as PydanticUser
from sqlalchemy import Select, func, literal, select, union_all
from mirix.schemas.episodic_event import EpisodicEvent as PydanticEpisodicEvent
from mirix.utils import enforce_types
from pydantic import BaseModel, Field
from sqlalchemy import select
from rapidfuzz import fuzz 
from mirix.schemas.agent import AgentState
from mirix.embeddings import embedding_model, parse_and_chunk_text
from mirix.services.utils import build_query, update_timezone

class EpisodicMemoryManager:
    """Manager class to handle business logic related to Episodic episodic_event items."""

    def __init__(self):
        from mirix.server.server import db_context
        self.session_maker = db_context

    @update_timezone
    @enforce_types
    def get_episodic_event_by_id(self, episodic_event_id: str) -> Optional[PydanticEpisodicEvent]:
        """
        Fetch a single episodic episodic_event record by ID.
        Raises NoResultFound if the record doesn't exist.
        """
        with self.session_maker() as session:
            try:
                episodic_event_item = EpisodicEvent.read(db_session=session, identifier=episodic_event_id)
                return episodic_event_item.to_pydantic()
            except NoResultFound:
                raise NoResultFound(f"Episodic episodic_event record with id {episodic_event_id} not found.")

    @enforce_types
    # def create_episodic_event(self, episodic_event: PydanticEpisodicEvent, actor: PydanticUser) -> PydanticEpisodicEvent:
    def create_episodic_event(self, episodic_event: PydanticEpisodicEvent) -> PydanticEpisodicEvent:
        """
        Create a new episodic episodic_event record.
        Uses the provided Pydantic model (PydanticEpisodicEvent) as input data.
        """

        # Convert the Pydantic model into a dict
        episodic_event_dict = episodic_event.model_dump()

        # Validate required fields if necessary (event_type, summary, etc.)
        required_fields = ["event_type", "summary"]
        for field in required_fields:
            if field not in episodic_event_dict or episodic_event_dict[field] is None:
                raise ValueError(f"Required field '{field}' is missing or None in episodic episodic_event data")

        # Set defaults if needed
        episodic_event_dict.setdefault("id", str(uuid.uuid4()))
        # episodic_event_dict.setdefault("organization_id", actor.organization_id)
        # Other fields like occurred_at, created_at, etc. 
        # might be auto-generated by the model or the DB

        # Create the episodic episodic_event item
        with self.session_maker() as session:
            episodic_event_item = EpisodicEvent(**episodic_event_dict)
            # episodic_event_item.create(session, actor=actor)
            episodic_event_item.create(session)
            return episodic_event_item.to_pydantic()

    @enforce_types
    def create_many_episodic_events(self, episodic_events: List[PydanticEpisodicEvent], actor: PydanticUser) -> List[PydanticEpisodicEvent]:
        """
        Create multiple episodic episodic_event records in one go.
        """
        return [self.create_episodic_event(e, actor) for e in episodic_events]

    @enforce_types
    def delete_event_by_id(self, id: str) -> None:
        """
        Delete an episodic episodic_event record by ID.
        """
        with self.session_maker() as session:
            try:
                episodic_event_item = EpisodicEvent.read(db_session=session, identifier=id)
                episodic_event_item.hard_delete(session)
            except NoResultFound:
                raise NoResultFound(f"Episodic episodic_event record with id {id} not found.")

    @enforce_types
    def insert_event(self, 
                     agent_state: AgentState,
                     event_type: str,
                     timestamp: datetime, 
                     actor: str, 
                     details: str,
                     summary: str,
                     organization_id: str) -> PydanticEpisodicEvent:

        try:

            # TODO: need to check if we need to chunk the text
            embed_model = embedding_model(agent_state.embedding_config)
            details_embedding = embed_model.get_text_embedding(details)
            summary_embedding = embed_model.get_text_embedding(summary)

            event = self.create_episodic_event(
                PydanticEpisodicEvent(
                    occurred_at=timestamp,
                    event_type=event_type,
                    actor=actor,
                    summary=summary,
                    details=details,
                    organization_id=organization_id,
                    summary_embedding=summary_embedding,
                    details_embedding=details_embedding,
                    embedding_config=agent_state.embedding_config,
                )
            )

            return event
        
        except Exception as e:
            raise e
    
    @update_timezone
    @enforce_types
    def list_episodic_events(self, 
                             agent_state: AgentState,
                             query: str = '', 
                             search_field: str = '',
                             search_method: str = 'semantic_match',
                             limit: Optional[int] = 50,
                             timezone_str: str = None) -> List[PydanticEpisodicEvent]:
        """
        List all episodic events
        """

        with self.session_maker() as session:
            
            # TODO: handle the case where query is None, we need to extract the 50 most recent results

            if query == '':
                result = session.execute(select(EpisodicEvent))
                episodic_events = result.scalars().all()
                return [event.to_pydantic() for event in episodic_events][-limit:]

            else:

                base_query = select(
                    EpisodicEvent.id.label("id"),
                    EpisodicEvent.created_at.label("created_at"),
                    EpisodicEvent.occurred_at.label("occurred_at"),
                    EpisodicEvent.actor.label("actor"),
                    EpisodicEvent.event_type.label("event_type"),
                    EpisodicEvent.summary.label("summary"),
                    EpisodicEvent.details.label("details"),
                    EpisodicEvent.summary_embedding.label("summary_embedding"),
                    EpisodicEvent.details_embedding.label("details_embedding"),
                    EpisodicEvent.embedding_config.label("embedding_config"),
                    EpisodicEvent.organization_id.label("organization_id"),
                    EpisodicEvent.metadata_.label("metadata_"),
                )

                if search_method == 'semantic_match':

                    embed_query = True
                    embedding_config = agent_state.embedding_config

                    main_query = build_query(
                        base_query=base_query,
                        query_text=query,
                        embed_query=embed_query,
                        embedding_config=embedding_config,
                        search_field = eval("EpisodicEvent." + search_field + "_embedding"),
                        target_class=EpisodicEvent,
                    )
            
                elif search_method == 'string_match':

                    search_field = eval("EpisodicEvent." + search_field)
                    main_query = base_query.where(func.lower(search_field).contains(query.lower()))

                elif search_method == 'fuzzy_match':

                    # load all cndidate events
                    result = session.execute(select(EpisodicEvent))
                    all_events = result.scalars().all()
                    scored_events = []
                    for event in all_events:
                        # Determine which field to use:
                        # 1. If a search_field is provided (like "summary" or "details") use that.
                        # 2. Otherwise, fallback to the summary.
                        if search_field and hasattr(event, search_field):
                            text_to_search = getattr(event, search_field)
                        else:
                            text_to_search = event.summary
                        
                        # Use fuzz.partial_ratio for short query matching against long text.
                        score = fuzz.partial_ratio(query.lower(), text_to_search.lower())
                        scored_events.append((score, event))

                    # Sort events in descending order of fuzzy match score.
                    scored_events.sort(key=lambda x: x[0], reverse=True)
                    # Optionally, you could filter out results below a certain score threshold.
                    top_events = [event for score, event in scored_events[:limit]]
                    episodic_events = top_events
                    # Return the list after converting to Pydantic.
                    return [event.to_pydantic() for event in episodic_events]

                if limit:
                    main_query = main_query.limit(limit)

                results = list(session.execute(main_query))

                episodic_events = []
                for row in results:
                    data = dict(row._mapping)
                    episodic_events.append(EpisodicEvent(**data))

                return [event.to_pydantic() for event in episodic_events]


    def update_event(self, 
                            event_id: str = None,
                            new_summary: str = None,
                            new_details: str = None):
        """
        Update the selected events
        """

        with self.session_maker() as session:
            
            # query = select(EpisodicEvent)
            # query = query.where(EpisodicEvent.id == event_id)
            # selected_event = session.execute(query).scalar_one_or_none()
            selected_event = EpisodicEvent.read(db_session=session, identifier=event_id)
            
            if not selected_event:
                raise ValueError(f"Episodic episodic_event record with id {event_id} not found.")

            if new_summary:
                selected_event.summary = new_summary
            if new_details:
                selected_event.details += "\n" + new_details
            
            selected_event.update(session)
            return selected_event.to_pydantic()
    